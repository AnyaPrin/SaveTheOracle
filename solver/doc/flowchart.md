# ソルバーの処理フロー

このドキュメントは、ユーザーが探索開始ボタンを押してから、解の経路が画面に表示されるまでの一連の処理の流れをまとめたものです。

## 1. 主要な概念定義

アプリケーション内では、盤面の状態を効率的に扱うために2つの主要なデータ形式を使用しています。

### 盤面状態文字列 (State String)

- **定義**: 盤面の状態を表現する20文字の文字列です。各文字が盤上の駒または空白マス (`.`) に対応します。
- **例**: `"BAACBAACDFFEDIJEG..H"`
- **用途**:
    - ユーザーによる初期盤面の入力。
    - 最終的な解の経路を画面に表示する際の形式。
    - 人間が直感的に理解しやすい。

### 盤面状態整数 (State Integer / `BigInt`)

- **定義**: 盤面状態文字列を、計算機が扱いやすい巨大な整数 (`BigInt`) に変換したものです。
- **例**: `11221122344536789001n` (あくまで概念的な例です)
- **用途**:
    - 探索アルゴリズム（ソルバー）内部での盤面状態の管理。
    - `Set` や `Map` を使った探索済みノードの高速な検索。
    - メモリ効率と計算速度を重視する場面で使用されます。

---

## 2. 処理フロー (`main.js`視点)

### フェーズ1: 初期化 (ページ読み込み時)

探索を開始する前に、`main.js` は必要なデータを非同期で準備します。

1.  **データファイルの取得**:
    -   `fetch` APIを使い、2種類のデータファイルを非同期で読み込みます。
        -   `optimal_path.json`: 最短解の経路データ。枝刈り（Pruning）に使用されます。
        -   `shared_visited.dat`: 開発者が事前に用意した探索済み盤面のデータ。ファイルサイズを最小化するため、**状態整数 (`BigInt`) を直接10バイトのバイナリ形式で保存**しています。
2.  **ローカルデータの読み込み**:
    -   ユーザーのブラウザの `localStorage` から、過去の探索で保存された探索済みデータを読み込みます。
3.  **データの前処理と保持**:
    -   読み込んだデータは、探索で効率的に利用するために **状態整数 (`BigInt`)** 形式に変換され、`Set` オブジェクトとしてメモリ上に保持されます。
        -   `optimalPathData`: `optimal_path.json` の内容を保持。
        -   `localVisitedData`: `shared_visited.dat` (バイナリ) と `localStorage` のデータをマージして保持。
    -   これらのデータ準備が完了すると、UI上の関連チェックボックスが有効化されます。

### フェーズ2: 探索の開始 (ユーザー操作)

ユーザーがアルゴリズムボタン（BFS, A*, IDA*）をクリックすると、`startSearch()` 関数が呼び出され、以下の処理が実行されます。

1.  **UIの更新**:
    -   `setUIState(true, ...)` を呼び出し、画面を「探索中」の状態に切り替えます。
    -   押されたボタンは「停止」ボタンに変化し、他の操作は無効化されます。
    -   探索アルゴリズムに応じた背景画像が表示されます。
2.  **探索オプションの準備**:
    -   現在の盤面 **状態文字列** を **状態整数 (`BigInt`)** に変換します。
    -   「枝刈り」や「探索データの利用」チェックボックスの状態を確認し、ソルバーに渡すオプションを決定します。
3.  **ソルバーの起動**:
    -   選択されたアルゴリズムに対応するソルバー（`BfsSolver`, `AstarSolver`, `IDAstarSolver`）のインスタンスを生成します。
    -   このとき、オプションオブジェクトとして以下の情報をソルバーに渡します。
        -   `initialState`: **探索開始地点の状態整数 (`BigInt`)**
        -   `onSuccess`, `onFailure`, `onProgress`: 探索の状況を `main.js` に通知するためのコールバック関数。
        -   `pruningOptions`, `preloadedVisited`: フェーズ1で準備したデータ。
    -   生成したソルバーの `.start()` メソッドを呼び出し、探索処理を開始します。

### フェーズ3: 探索の実行 (ソルバー内部)

ソルバーは `main.js` から独立して、バックグラウンドで探索処理を実行します。

1.  **チャンク処理**: UIのフリーズを防ぐため、探索は一度に数百ノードずつ処理され、`setTimeout` を介して次のチャンク処理を呼び出す、というサイクルを繰り返します。
2.  **進捗通知**: チャンク処理の合間に `onProgress` コールバックを呼び出し、探索済みノード数などの進捗を `main.js` に通知します。`main.js` の `handleProgress` 関数がこれを受け取り、UIをリアルタイムで更新します。
3.  **解の発見**: ゴール状態に到達すると、ソルバーは `onSuccess` コールバックを呼び出します。このとき、解の経路（スタートからゴールまでの一連の盤面）を **状態整数 (`BigInt`) の配列** として `main.js` に返します。

### フェーズ4: 結果の受け取りと表示 (`main.js`内)

ソルバーから `onSuccess` が呼び出されると、`main.js` の `handleSuccess()` 関数が実行されます。

1.  **UIの更新**: `setUIState(false)` を呼び出し、画面を「探索終了」状態に戻します。
2.  **経路データの整形**:
    -   ソルバーから返された `result.path`（**状態整数の配列**）を受け取ります。
    -   **【駒の一貫性復元処理】**:
        -   探索アルゴリズ厶は効率化のため、駒の「形」と「大きさ」のみを区別し、駒の名前（A, B, C...）は区別しません。そのため、ソルバーから返ってきた経路をそのまま表示すると、一手ごとに駒の名前が入れ替わってしまう問題が発生します。
        -   この問題を解決するため、`handleSuccess` 内で経路を1ステップずつ検証します。
        -   前のステップの盤面と現在のステップの盤面を比較し、「動かなかった駒」と「動いた駒」を特定します。
        -   「動いた駒」に対して、前のステップでの名前を正しく引き継がせることで、駒のアイデンティティを復元します。
        -   この処理をゴールまでの全ステップで繰り返し、**状態文字列による一貫性のとれた最適解経路**（`correctedPathStrings`）を生成します。
3.  **画面への描画**:
    -   最終的に整形された **状態文字列の配列** を `SolutionDisplay.displaySolution()` に渡し、解の経路を画面のソリューションパネルに描画させます。
    -   手数や探索時間などのサマリー情報を画面に表示します。
