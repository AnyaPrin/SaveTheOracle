<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <title>Variable Speed Plotting</title>
    <style>
      body { margin: 0; overflow: hidden; background-color: #000; }
      canvas { display: block; }
      #progress-text {
          position: absolute; top: 20px; left: 20px;
          color: #fff; font-family: sans-serif;
          z-index: 100;
      }
    </style>
  </head>
  <body>
    <div id="progress-text">Loading...</div>
    <script type="importmap">
      {
          "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
          }
      }
    </script>
    <script src="data.json"></script>    
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

      // シーン設定
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      camera.position.z = 5;

      // カメラコントロール
      const controls = new OrbitControls(camera, renderer.domElement);

      // UI要素
      const progressText = document.getElementById('progress-text');

      // オブジェクトの準備
      const pointsGeometry = new THREE.BufferGeometry();
      const lineGeometry = new THREE.BufferGeometry();
      const pointsMaterial = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.1 });
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
      const pointsObject = new THREE.Points(pointsGeometry, pointsMaterial);
      const linesObject = new THREE.LineSegments(lineGeometry, lineMaterial);
      scene.add(pointsObject, linesObject);
      
      // JSONデータ
      let vertexIndex = 0;
      const jsonData = {
          "vertices": []
      };
      
      
      const allVertices = jsonData.vertices;
      let lastPlotCount = 0;
      let plotIndex = 0;
      const totalVertices = allVertices.length;
      const totalTime = 5000; // 5秒で完了
      let elapsedTime = 0;
      const intervalTime = 16; // 約60fps

      const interval = setInterval(updateProgress, intervalTime);
      
      function updateProgress() {
          elapsedTime += intervalTime;

          if (elapsedTime > totalTime) {
              clearInterval(interval);
              elapsedTime = totalTime;
              progressText.textContent = `Complete!`;
          }

          // プログレスの計算（0から1の範囲）
          const t = Math.min(elapsedTime / totalTime, 1);
          // サイン関数によるプログレスのイージング
          // 0から1へ加速し、1から2へ減速するようなカーブ
          // t = 0から0.5まではプログレスの進みが遅く、0.5から1までは速くなる
          const easedProgress = Math.sin(t * Math.PI - Math.PI / 2) * 0.5 + 0.5;

          // プロットする頂点数を計算
          const plotCount = Math.floor(totalVertices * easedProgress);

          // 今回追加する頂点の数を計算
          const newVerticesCount = plotCount - lastPlotCount;

          if (newVerticesCount > 0) {
              const newPositions = [];
              const newLines = [];
              let prePosition = null;

              // 新規にプロットする頂点を処理
              for (let i = lastPlotCount; i < plotCount; i++) {
                  const vertexData = allVertices[i];
                  const currentPosition = new THREE.Vector3(vertexData.x, vertexData.y, vertexData.z);
                  newPositions.push(currentPosition.x, currentPosition.y, currentPosition.z);
                  
                  if (i > 0) {
                      const preVertexData = allVertices[i - 1];
                      prePosition = new THREE.Vector3(preVertexData.x,preVertexData.y,preVertexData.z);
                      newLines.push(prePosition.x, prePosition.y, prePosition.z);
                      newLines.push(currentPosition.x, currentPosition.y, currentPosition.z);
                  }
              }
              
              // 既存のジオメトリに新しいデータを追加
              const currentPositions = pointsGeometry.attributes.position.array;
              const newPositionsArray = new Float32Array([...currentPositions, ...newPositions]);
              pointsGeometry.setAttribute('position', new THREE.BufferAttribute(newPositionsArray, 3));

              const currentLines = lineGeometry.attributes.position.array;
              const newLinesArray = new Float32Array([...currentLines, ...newLines]);
              lineGeometry.setAttribute('position', new THREE.BufferAttribute(newLinesArray, 3));
          }

          lastPlotCount = plotCount;
          progressText.textContent = `Loading: ${Math.floor(easedProgress * 100)}%`;
      }

      // アニメーションループ
      function animate() {
          requestAnimationFrame(animate);
          controls.update();
          renderer.render(scene, camera);
      }

      // 初期化
      animate();
      window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
