<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <title>ちらつきを抑える</title>
    <style>
      body {
          background-color: #333;
          display: flex;
          justify-content: center;
          align-items: center;
          height: 100vh;
          margin: 0;
      }
      canvas {
          background-color: #000;
          border: 2px solid #fff;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const offscreenCanvas = document.createElement('canvas');
      const offscreenCtx = offscreenCanvas.getContext('2d');
      offscreenCanvas.width = canvas.width;
      offscreenCanvas.height = canvas.height;
      const SPRITE_MAP = {
          'D': [0, 0, 200, 200], 'R': [200, 0, 200, 200],
          'U': [400, 0, 200, 200], 'L': [600, 0, 200, 200],
      };
      class GameLoop {
	  constructor(mainCanvas) {
              this.mainCanvas = mainCanvas;
              this.mainCtx = mainCanvas.getContext('2d');
              // オフスクリーンキャンバスは一つだけ
              this.offscreenCanvas = document.createElement('canvas');
              this.offscreenCtx = this.offscreenCanvas.getContext('2d');
              this.offscreenCanvas.width = mainCanvas.width;
              this.offscreenCanvas.height = mainCanvas.height;
              this.animators = [];
              this.lastUpdateTime = 0;
	  }
	  // アニメーターを追加
	  addAnimator(animator) {
              this.animators.push(animator);
	  }
	  start() {
              requestAnimationFrame(this.animate.bind(this));
	  }
	  animate(timestamp) {
              // オフスクリーンキャンバスをクリア
              this.offscreenCtx.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
              // すべてのアニメーターを更新＆描画
              this.animators.forEach(animator => {
		  animator.update(timestamp);
		  animator.draw(this.offscreenCtx);
              });
              // オフスクリーンキャンバスをメインにコピー
              this.mainCtx.clearRect(0, 0, this.mainCanvas.width, this.mainCanvas.height);
              this.mainCtx.drawImage(this.offscreenCanvas, 0, 0);

              requestAnimationFrame(this.animate.bind(this));
	  }
      }      

      class SpriteAnimator {
	  constructor(image, spriteMap, animationKeys, frameInterval, x, y) {
              this.image = image;
              this.spriteMap = spriteMap;
              this.animationKeys = animationKeys;
              this.frameInterval = frameInterval;
              this.x = x;
              this.y = y;
              this.currentFrameIndex = 0;
              this.lastUpdateTime = 0;
	  }
	  update(timestamp) {
              if (timestamp - this.lastUpdateTime > this.frameInterval) {
		  this.currentFrameIndex = (this.currentFrameIndex + 1) % this.animationKeys.length;
		  this.lastUpdateTime = timestamp;
              }
	  }
	  draw(ctx) {
              const currentKey = this.animationKeys[this.currentFrameIndex];
              const coords = this.spriteMap[currentKey];
              ctx.drawImage(this.image, ...coords, this.x, this.y, coords[2], coords[3]);
	  }
      }
      const spriteSheet = new Image();
      spriteSheet.src = 'img/imagesheet.png'; 
      let animator1, animator2;
      spriteSheet.onload = () => {
          animator1 = new SpriteAnimator(spriteSheet, SPRITE_MAP, ['D', 'R', 'U', 'L'], 250, 100, 100);
          animator2 = new SpriteAnimator(spriteSheet, SPRITE_MAP, ['U', 'L', 'D', 'R'], 150, 400, 300);
          requestAnimationFrame(gameLoop);
      };
      function gameLoop(timestamp) {
          // ★★★ メインのキャンバスではなく、オフスクリーンキャンバスをクリア ★★★
          offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
          // ★★★ 描画もオフスクリーンキャンバスに対して行う ★★★
          if (animator1) {
              animator1.update(timestamp);
              animator1.draw(offscreenCtx);
          }
          if (animator2) {
              animator2.update(timestamp);
              animator2.draw(offscreenCtx);
          }
          // ★★★ 最後に、完成したオフスクリーンキャンバスをメインにコピー ★★★
          ctx.clearRect(0, 0, canvas.width, canvas.height); // メインをクリア
          ctx.drawImage(offscreenCanvas, 0, 0); // オフスクリーンをコピー
          requestAnimationFrame(gameLoop);
      }
    </script>
  </body>
</html>
