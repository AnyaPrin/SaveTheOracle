# 状態表現に関する覚え書き (String vs BigInt)

このドキュメントは、パズルの盤面状態を表現する方法について、従来の「状態文字列」と新しい「状態整数 (BigInt)」を比較し、その設計思想と実装についてまとめたものです。

## 1. 概要

探索アルゴリズム（特にBFSやA*）では、`visited` セットに数百万から数千万の盤面状態を保存する必要があります。このとき、各状態のデータ表現がメモリ使用量と処理速度に直接影響します。

- **状態文字列 (String)**: 人間が読みやすいが、メモリ効率と処理速度に課題がある。
- **状態整数 (BigInt)**: メモリ効率と処理速度に優れるが、可読性が低い。

パフォーマンスを最大化するため、探索のコア部分では「状態整数」を利用し、UI表示やデバッグ時には「状態文字列」に変換するハイブリッドなアプローチを採用します。

---

## 2. 状態文字列 (String) 表現

### 形式
盤面を左上から右下へスキャンした20文字の文字列で表現します。

- **例**: `"BAACBAACDFFEDIJEG..H"`

### 長所
- **可読性**: 人間が直接読んで盤面を理解できるため、デバッグが非常に容易です。
- **実装の容易さ**: 文字列操作は直感的で、初期実装に適しています。

### 短所
- **メモリ消費**: JavaScriptの文字列は内部的にUTF-16で、1文字あたり2バイトを消費します。
  - `20文字 * 2バイト/文字 = 40バイト` + オブジェクトのオーバーヘッド。`visited`セットに100万件保存すると約40MBを消費します。
- **処理速度**: 駒の移動や正規化のために `split`, `join`, `replace` などの文字列操作を繰り返すと、新しい文字列が頻繁に生成され、パフォーマンスのボトルネックになります。
---



- **処理速度**: 駒の移動や正規化のために `split`, `join`, `replace` などの文字列操作を繰り返すと、新しい文字列が頻繁に生成され、パフォーマンスのボトルネックになります。

---

## 3. 状態整数 (BigInt) 表現

### 形式
盤面の20マスを80ビットの単一の整数 (`BigInt`) で表現します。

### エンコード方法

1.  **4ビット/マス**: 盤面の各マスは、駒10種 (`A`~`J`) と空きマス (`.`) の最大11種類の状態を取ります。これを表現するには4ビット (`2^4 = 16`) あれば十分です。
2.  **マッピング**: 各駒の文字を0から10の数値にマッピングします。
    ```javascript
    const CHAR_TO_VALUE = { '.': 0, 'A': 1, 'B': 2, ... , 'J': 10 };
    ```
3.  **ビット配置**: 20マス分の状態（各4ビット）を、左のマスほど上位ビットになるように配置します。これにより、80ビットの整数が完成します。
    - マス 0 (左上) → ビット 76-79
    - マス 1 → ビット 72-75
    - ...
    - マス 19 (右下) → ビット 0-3

### 長所
- **メモリ効率**: 80ビットは **10バイト** です。文字列表現に比べてメモリ使用量を約75%削減できます。`visited`セットに100万件保存しても約10MBで済み、ブラウザのメモリ上限に達しにくくなります。
- **処理速度**: `visited.has(state)`のような検索処理や、盤面全体を操作する正規化処理を、文字列操作よりもはるかに高速なビット演算で行うことができます。これにより、探索ループ全体のパフォーマンスが向上します。

### 短所
- **可読性の低下**: `151136570413640633063936` のような数値から盤面を即座に理解することは困難です。
- **コードの複雑化**: ビット演算を多用するため、コードが直感的でなくなり、デバッグやメンテナンスの難易度が上がります。

---

## 4. 相互変換関数

状態文字列と状態整数を相互に変換するためのユーティリティ関数です。これらの関数は、`BigInt`表現への移行における心臓部となります。

### `stateToBigInt(stateString)`

文字列を`BigInt`にエンコードします。入力文字列の検証（長さ、使用文字）も行います。

```javascript
const CHAR_TO_VALUE = { '.': 0, 'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5, 'F': 6, 'G': 7, 'H': 8, 'I': 9, 'J': 10 };

function stateToBigInt(stateString) {
    if (stateString.length !== 20) return null;

    let bigIntState = 0n;
    for (let i = 0; i < stateString.length; i++) {
        const char = stateString[i];
        const value = CHAR_TO_VALUE[char];
        if (value === undefined) return null;
        
        bigIntState |= (BigInt(value) << BigInt((19 - i) * 4));
    }
    return bigIntState;
}
```

### `bigIntToState(bigIntState)`

`BigInt`をデコードして文字列に戻します。UIでの結果表示などに使用します。

```javascript
const VALUE_TO_CHAR = ['.', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];

function bigIntToState(bigIntState) {
    let stateString = '';
    for (let i = 0; i < 20; i++) {
        const shift = BigInt((19 - i) * 4);
        const value = Number((bigIntState >> shift) & 0b1111n);
        stateString += VALUE_TO_CHAR[value] || '?';
    }
    return stateString;
}
```

## 5. 今後の展望

この`BigInt`表現を基盤として、以下の改善を進めます。

- **コアロジックの最適化**: `getPossibleNextStates` や `normalizeState` などの関数を、ビット演算を全面的に使用するように書き換え、探索速度を向上させます。
- **PDB (パターンデータベース) の構築**: IDA*アルゴリズムのヒューリスティック関数を改善するため、特定の駒の配置パターンとその最短手数を事前計算したデータベースを構築します。この際、コンパクトな`BigInt`表現がキーとして非常に有効に機能します。
